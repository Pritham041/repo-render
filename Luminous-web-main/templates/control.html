{% extends "base.html" %}

{% block title %}Control Panel{% endblock %}

{% block content %}
<style>
    /*
     * Custom ghost class for Sortable.js
     */
    .sortable-ghost {
        background-color: var(--bg-muted-light);
        opacity: 0.5;
    }
    .dark .sortable-ghost {
        background-color: var(--bg-muted-dark);
        opacity: 0.5;
    }
    /*
     * Custom style for the toggle switch
     */
    .custom-toggle-switch {
        position: relative;
        display: inline-block;
        width: 60px;
        height: 34px;
    }
    .custom-toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        -webkit-transition: .4s;
        transition: .4s;
        border-radius: 34px;
    }
    .slider:before {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        -webkit-transition: .4s;
        transition: .4s;
        border-radius: 50%;
    }
    input:checked + .slider {
        background-color: #2196F3;
    }
    input:focus + .slider {
        box-shadow: 0 0 1px #2196F3;
    }
    input:checked + .slider:before {
        -webkit-transform: translateX(26px);
        -ms-transform: translateX(26px);
        transform: translateX(26px);
    }

    /* Webcam and Monitoring styles (unchanged) */
    #webcam-card-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 320px;
        height: 240px;
        border: 2px solid var(--primary-accent-light);
        background-color: var(--bg-card-light);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        border-radius: 0.5rem;
        overflow: hidden;
        z-index: 40;
    }
    .dark #webcam-card-container {
        border: 2px solid var(--primary-accent-dark);
        background-color: var(--bg-card-dark);
    }
    #webcam-video {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    #ai-monitoring-card {
        max-width: 500px;
    }

    /* Animation for active monitoring buttons */
    @keyframes pulse-glow {
        0%, 100% {
            box-shadow: 0 0 0 0 rgba(22, 163, 74, 0.7);
        }
        50% {
            box-shadow: 0 0 10px 5px rgba(22, 163, 74, 0);
        }
    }
    .monitoring-active-btn {
        animation: pulse-glow 2s infinite;
        border-color: #16a34a;
    }

    /* MODIFICATION: Style for the new floating Add Room button */
    #add-room-btn-container {
        position: fixed;
        /* Positioned higher to avoid notifications which usually appear at bottom: 1rem */
        bottom: 2.5rem; /* 40px */
        right: 2.5rem; /* 40px */
        z-index: 50;
    }
</style>

<div class="container mx-auto">
    <div class="text-center mb-8">
        <h1 class="text-4xl font-extrabold mb-2 text-primary-accent">Relay Control Panel</h1>
        <p class="text-gray-700 dark:text-gray-300">Manage your rooms and appliances.</p>
    </div>

    <div id="rooms-view" class="transition-transform duration-500">

        <div class="text-center mb-4">
            <h2 class="text-3xl font-bold text-text-card-foreground">Room Center</h2>
        </div>

        <div class="flex justify-center items-center space-x-4 mb-8">
            <button id="global-open-webcam-btn" class="bg-blue-500 text-white px-4 py-2 rounded-md font-semibold hover:bg-blue-600 transition-colors">
                <i class="fas fa-camera mr-2"></i>Open Webcam
            </button>
            <button id="global-start-monitoring-btn" class="bg-teal-500 text-white px-4 py-2 rounded-md font-semibold hover:bg-teal-600 transition-colors">
                <i class="fas fa-eye mr-2"></i>Start Monitoring
            </button>
        </div>

        <div id="global-webcam-container" class="hidden w-full max-w-lg mx-auto mb-4 bg-card border rounded-lg shadow-md">
            <video id="global-webcam-video" autoplay playsinline class="w-full h-auto rounded-lg"></video>
        </div>
        <div id="global-monitoring-card" class="hidden w-full max-w-lg mx-auto mb-4 p-4 bg-card border rounded-lg shadow-md text-center">
            <h3 class="text-lg font-semibold mb-2">Global AI Monitoring Active</h3>
            <p id="global-monitoring-status" class="text-lg text-teal-500 font-bold">Initializing...</p>
        </div>
        
        <div id="room-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            </div>

        <div id="add-room-btn-container">
             <button id="add-room-btn" class="bg-secondary-accent text-white px-6 py-3 rounded-full font-semibold shadow-lg hover:bg-opacity-80 transition-colors flex items-center">
                <i class="fas fa-plus-circle mr-2"></i>Add Room
            </button>
        </div>
    </div>
    
    <div id="appliances-view" class="hidden transition-transform duration-500">
        <div class="flex flex-col items-center mb-4">
            <div class="w-full flex justify-between items-center mb-4">
                <button id="back-to-rooms-btn" class="bg-gray-400 text-white px-4 py-2 rounded-md font-semibold hover:bg-gray-500 transition-colors">
                    <i class="fas fa-arrow-left mr-2"></i>Back to Rooms
                </button>
                <div class="flex-grow flex justify-center">
                    <h2 class="text-2xl font-bold text-text-card-foreground" id="appliances-heading"></h2>
                </div>
                <div></div>
            </div>
            
            <div class="flex space-x-4 mb-4">
                <button id="open-webcam-btn" class="bg-secondary-accent text-white px-4 py-2 rounded-md font-semibold hover:bg-opacity-80 transition-colors">
                    <i class="fas fa-camera mr-2"></i>Open Webcam
                </button>
                <button id="start-monitoring-btn" onclick="toggleMonitoring(currentRoomId)" class="bg-primary-accent text-white px-4 py-2 rounded-md font-semibold hover:bg-opacity-80 transition-colors">
                    <i class="fas fa-eye mr-2"></i>Start Monitoring
                </button>
            </div>

            <div id="ai-monitoring-card" class="hidden bg-card text-card-foreground rounded-xl border p-4 shadow-sm w-full max-w-lg mx-auto mt-4 flex flex-col items-center text-center">
                <h3 class="text-lg font-semibold mb-2">AI Monitoring Active</h3>
                <p id="monitoring-status" class="text-lg text-primary-accent font-bold">Awaiting human detection...</p>
            </div>

            <div id="webcam-card-container" class="hidden fixed bottom-20 right-20 w-80 h-60 rounded-xl shadow-xl z-50 overflow-hidden bg-card border border-gray-200 dark:border-gray-700">
                <div class="flex items-center justify-between p-2 border-b border-gray-200 dark:border-gray-700">
                    <h4 class="text-sm font-semibold">Live Feed</h4>
                    <button id="close-webcam-btn" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <video id="webcam-video-live" autoplay class="w-full h-full object-cover"></video>
            </div>
        </div>

        <div id="appliance-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            </div>
        <button id="add-appliance-btn" class="fixed bottom-8 right-8 bg-secondary-accent text-white px-6 py-3 rounded-full font-semibold shadow-lg hover:bg-opacity-80 transition-colors">
            <i class="fas fa-plus mr-2"></i> Add Appliance
        </button>
    </div>


    <!-- Room Settings Modal -->
    <div id="settings-room-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center hidden z-50">
        <div class="bg-card p-6 rounded-lg shadow-xl w-80">
            <h3 class="text-xl font-bold mb-4 text-text-card-foreground">Edit Room Settings</h3>
            <form id="settings-room-form">
                <input type="hidden" id="edit-room-id">
                <label for="edit-room-name" class="block text-text-card-foreground mb-2">Room Name:</label>
                <input type="text" id="edit-room-name" name="name" class="w-full p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none" required>
                <div class="flex justify-between items-center mt-4">
                    <p class="text-sm font-medium text-gray-700 dark:text-gray-300">AI Control</p>
                    <button type="button" role="switch" id="ai-control-switch" data-state="off" class="toggle-switch-button">
                        <span data-slot="switch-thumb" class="bg-white pointer-events-none block h-5 w-5 rounded-full ring-0 transition-transform"></span>
                    </button>
                </div>
                <div class="flex justify-between space-x-4 mt-6">
                    <button type="button" id="delete-room-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors flex-grow">Delete</button>
                    <button type="button" id="cancel-room-settings-btn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-600 transition-colors">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-secondary-accent text-white rounded-lg hover:bg-opacity-80 transition-colors">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modals for adding rooms and appliances -->
    <div id="add-room-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center hidden z-50">
        <div class="bg-card p-6 rounded-lg shadow-xl w-80">
            <h3 class="text-xl font-bold mb-4 text-text-card-foreground">Add New Room</h3>
            <form id="add-room-form">
                <label for="new-room-name" class="block text-text-card-foreground mb-2">Room Name:</label>
                <input type="text" id="new-room-name" name="name" class="w-full p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none" required>
                <div class="flex justify-end space-x-4 mt-6">
                    <button type="button" id="cancel-room-btn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-600 transition-colors">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-secondary-accent text-white rounded-lg hover:bg-opacity-80 transition-colors">Add</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add Appliance Modal -->
    <div id="add-appliance-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center hidden z-50">
        <div class="bg-card p-6 rounded-lg shadow-xl w-80">
            <h3 class="text-xl font-bold mb-4 text-text-card-foreground">Add New Appliance</h3>
            <form id="add-appliance-form">
                <label for="new-appliance-name" class="block text-text-card-foreground mb-2">Appliance Name:</label>
                <input type="text" id="new-appliance-name" name="name" class="w-full p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none" required>
                <label for="new-appliance-relay" class="block text-text-card-foreground mb-2 mt-4">Relay Number (1-4):</label>
                <input type="number" id="new-appliance-relay" name="relay" min="1" max="4" class="w-full p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none" required>
                <div class="flex justify-end space-x-4 mt-6">
                    <button type="button" id="cancel-appliance-btn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-600 transition-colors">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-secondary-accent text-white rounded-lg hover:bg-opacity-80 transition-colors">Add</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Appliance Settings Modal -->
    <div id="settings-appliance-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center hidden z-50">
        <div class="bg-card p-6 rounded-lg shadow-xl w-80">
            <h3 class="text-xl font-bold mb-4 text-text-card-foreground">Edit Appliance Settings</h3>
            <form id="settings-appliance-form">
                <input type="hidden" id="settings-edit-room-id">
                <input type="hidden" id="edit-appliance-id">
                <label for="edit-appliance-name" class="block text-text-card-foreground mb-2">Appliance Name:</label>
                <input type="text" id="edit-appliance-name" name="name" class="w-full p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none" required>
                
                <div class="mt-4">
                    <label for="edit-room-selector" class="block text-text-card-foreground mb-2">Change Room:</label>
                    <select id="edit-room-selector" class="w-full p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>

                <div class="mt-4">
                    <div class="advanced-settings-toggle cursor-pointer font-semibold text-secondary-accent hover:underline">
                        Advanced Settings <i class="fas fa-caret-down"></i>
                    </div>
                    <div id="advanced-settings" class="hidden pt-2 border-t mt-2">
                        <label for="edit-appliance-relay" class="block text-text-card-foreground mb-2">Relay Number (1-4):</label>
                        <input type="number" id="edit-appliance-relay" name="relay" min="1" max="4" class="w-full p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none" required>
                    </div>
                </div>

                <div class="flex justify-between space-x-4 mt-6">
                    <button type="button" id="delete-appliance-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors flex-grow">Delete</button>
                    <button type="button" id="cancel-appliance-settings-btn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-600 transition-colors">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-secondary-accent text-white rounded-lg hover:bg-opacity-80 transition-colors">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Timer Modal -->
    <div id="timer-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center hidden z-50">
        <div class="bg-card p-6 rounded-lg shadow-xl w-80">
            <h3 class="text-xl font-bold mb-4 text-text-card-foreground">Set Timer</h3>
            <form id="timer-form">
                <input type="hidden" id="timer-room-id">
                <input type="hidden" id="timer-appliance-id">

                <div class="space-y-4">
                    <div>
                        <p class="block text-text-card-foreground mb-2 font-medium">Set a Duration</p>
                        <div class="flex space-x-2 items-center">
                            <input type="number" id="timer-duration-hours" min="0" placeholder="Hours" class="w-1/2 p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none">
                            <input type="number" id="timer-duration-minutes" min="0" placeholder="Minutes" class="w-1/2 p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none">
                        </div>
                    </div>

                    <div class="flex items-center justify-center text-gray-400 dark:text-gray-500 font-bold">
                        <hr class="w-1/3 mr-2">OR<hr class="w-1/3 ml-2">
                    </div>

                    <div>
                        <p class="block text-text-card-foreground mb-2 font-medium">Set a Specific Time</p>
                        <input type="datetime-local" id="timer-datetime" class="w-full p-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 focus:outline-none">
                    </div>
                </div>

                <div class="flex justify-between space-x-4 mt-6">
                    <button type="button" id="cancel-timer-btn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-600 transition-colors">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-secondary-accent text-white rounded-lg hover:bg-opacity-80 transition-colors">Set Timer</button>
                </div>
            </form>
        </div>
    </div>

    <!-- General Purpose Confirmation Modal -->
    <div id="confirmation-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center hidden z-[100]">
        <div class="bg-card p-6 rounded-lg shadow-xl w-80 max-w-sm mx-auto">
            <h3 id="confirmation-title" class="text-xl font-bold mb-4 text-text-card-foreground"></h3>
            <p id="confirmation-message" class="text-text-foreground mb-6"></p>
            <div class="flex justify-end space-x-4">
                <button id="confirm-cancel-btn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 dark:text-gray-200 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-600 transition-colors">Cancel</button>
                <button id="confirm-action-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Webcam Container -->
    <div id="webcam-card-container" class="hidden fixed bottom-20 right-20 w-80 h-60 rounded-xl shadow-xl z-50 overflow-hidden bg-card border border-gray-200 dark:border-gray-700">
        <div class="flex items-center justify-between p-2 border-b border-gray-200 dark:border-gray-700">
            <h4 class="text-sm font-semibold">Live Feed</h4>
            <button id="close-webcam-btn" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <video id="webcam-video-live" autoplay class="w-full h-full object-cover"></video>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

<script>
    let isGlobalMonitoring = false;
    let globalMonitoringStream = null;
    let globalMonitoringIntervalId = null;
    let lastGlobalEmailTime = null;

    let timerIntervals = {};
    let allRoomsData = [];
    let roomSortable = null;
    let applianceSortable = null;
    let webcamStream = null;
    let model = null;
    let monitoringVideo = null;
    let monitoringIntervalId = null;
    const monitoringCard = document.getElementById('ai-monitoring-card');
    const monitoringStatus = document.getElementById('monitoring-status');
    const webcamCanvas = document.createElement('canvas');
    const webcamBtn = document.getElementById('open-webcam-btn');
    const monitoringBtn = document.getElementById('start-monitoring-btn');
    const liveWebcamVideo = document.getElementById('webcam-video-live');
    const webcamCardContainer = document.getElementById('webcam-card-container');
    const closeWebcamBtn = document.getElementById('close-webcam-btn');
    const backToRoomsBtn = document.getElementById('back-to-rooms-btn');
    const globalWebcamBtn = document.getElementById('open-webcam-global-btn');
    const globalMonitoringBtn = document.getElementById('start-monitoring-global-btn');
    const globalMonitoringCard = document.getElementById('ai-monitoring-global-card');
    const globalMonitoringStatus = document.getElementById('monitoring-status-global');

    let modelLoaded = false;

    let pendingGlobalAction = null; // 'webcam' or 'monitoring'

    let globalWebcamStream = null;

    let currentRoomId = null;
    const activeMonitors = new Map(); // Manages all independent monitoring sessions
    let aiControlInterval = 5000;
    let lastEmailTime = null;
    let isGlobalMonitoringActive = false;
    const monitoringVideoElement = document.createElement('video');
    // ... keep other variables like webcamStream, allRoomsData, etc.

    const loadModel = async () => {
        if (model || modelLoaded) return;
        try {
            showNotification('Loading AI model...', 'on');
            model = await cocoSsd.load();
            modelLoaded = true;
            showNotification('AI model loaded successfully.', 'on');
            console.log('AI model loaded successfully.');
        } catch (error) {
            console.error('Failed to load model:', error);
            showNotification('Failed to load AI model.', 'off');
        }
    };

    
        
    const detectHumans = async (roomId) => { // roomId is now optional
        
        // --- Case 1: This is a GLOBAL monitoring loop ---
        if (!roomId && isGlobalMonitoringActive) {
            if (!isMonitoring || !model) return; // Stop if turned off
            const videoElement = monitoringVideoElement; // Use the single global video element
            if (!videoElement.srcObject || videoElement.paused) {
                console.log("Global monitoring stream not available, stopping detection.");
                toggleGlobalMonitoring();
                return;
            }
            const canvas = document.createElement('canvas');
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            
            try {
                const predictions = await model.detect(canvas);
                const humanDetections = predictions.filter(p => p.class === 'person');
                const humanDetected = predictions.some(p => p.class === 'person');
                const statusElement = document.getElementById('global-monitoring-status');
                statusElement.textContent = humanDetected ? 'Human detected! Controlling all appliances.' : 'No human detected. Awaiting...';
                
                await fetch('/api/global-ai-signal', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ state: humanDetected })
                });
                
                // Global email alerts - rate-limited to once every 10 minutes
                if (!window.globalLastEmailTime) {
                    window.globalLastEmailTime = null;
                }
                
                if (humanDetected && (window.globalLastEmailTime === null || (Date.now() - window.globalLastEmailTime) > 600000)) {
                    console.log("Global email time threshold passed. Sending alert...");
                    
                    // Create alert canvas with proper dimensions and enhanced visualization
                    const alertCanvas = document.createElement('canvas');
                    const videoWidth = videoElement.videoWidth || 640;
                    const videoHeight = videoElement.videoHeight || 480;
                    alertCanvas.width = videoWidth;
                    alertCanvas.height = videoHeight;
                    const alertCtx = alertCanvas.getContext('2d');
                    
                    // Draw the video frame first
                    alertCtx.drawImage(videoElement, 0, 0, videoWidth, videoHeight);
                    
                    // Set up styling for bounding boxes
                    alertCtx.strokeStyle = '#FF0000';
                    alertCtx.lineWidth = 3;
                    alertCtx.font = '16px Arial';
                    
                    // Draw bounding boxes around each detected person
                    humanDetections.forEach((detection, index) => {
                        const [x, y, width, height] = detection.bbox;
                        
                        // Draw the rectangle
                        alertCtx.strokeRect(x, y, width, height);
                        
                        // Add confidence score label
                        const confidence = Math.round(detection.score * 100);
                        const label = `Person ${confidence}%`;
                        
                        // Draw label background
                        const textMetrics = alertCtx.measureText(label);
                        alertCtx.fillStyle = '#FF0000';
                        alertCtx.fillRect(x, Math.max(y - 20, 0), textMetrics.width + 8, 20);
                        
                        // Draw label text
                        alertCtx.fillStyle = '#FFFFFF';
                        alertCtx.fillText(label, x + 4, Math.max(y - 4, 16));
                        
                        console.log(`Global Detection ${index + 1}: bbox=[${x}, ${y}, ${width}, ${height}], confidence=${confidence}%`);
                    });
                    
                    try {
                        // Convert to base64 for email
                        const imageData = alertCanvas.toDataURL('image/jpeg', 0.8);
                        
                        // Validate image data before sending
                        if (imageData && imageData.length > 100) {
                            await fetch('/api/send-detection-email', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    image_data: imageData,
                                    room_name: 'Global Monitoring',
                                    room_id: 'global',
                                    is_global: true
                                })
                            });
                            
                            window.globalLastEmailTime = Date.now();
                            console.log("Global detection email sent successfully");
                        } else {
                            console.error("Invalid image data for global email");
                        }
                    } catch (emailError) {
                        console.error("Failed to send global detection email:", emailError);
                    }
                }
                
            } catch (error) {
                console.error("Error during global detection:", error);
            }
            
            // Reschedule the global loop
            if (isGlobalMonitoringActive) {
                monitoringIntervalId = setTimeout(() => detectHumans(), aiControlInterval);
            }
            return; // End the function here for the global case
        }
        
        // --- Case 2: This is a PER-ROOM monitoring loop ---
        if (roomId) {
            const monitor = activeMonitors.get(roomId);
            if (!monitor || !monitor.isRunning) return; // Stop if cancelled
            const videoElement = monitor.videoElement;
            if (!videoElement.srcObject || videoElement.paused) {
                console.error(`Stream for room ${roomId} is not available. Stopping monitor.`);
                toggleMonitoring(roomId); // Gracefully shut down this specific monitor
                return;
            }
            const canvas = document.createElement('canvas');
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            
            try {
                const predictions = await model.detect(canvas);
                const humanDetections = predictions.filter(p => p.class === 'person');
                const humanDetected = predictions.some(p => p.class === 'person');
                
                await fetch('/api/ai-detection-signal', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ room_id: roomId, state: humanDetected })
                });
                
                if (roomId === currentRoomId) {
                    const currentRoom = allRoomsData.find(r => r.id === roomId);
                    const roomName = currentRoom ? currentRoom.name : 'Unknown Room';
                    const statusElement = document.getElementById('monitoring-status');
                    
                    if (statusElement) {
                        if (humanDetected) {
                            statusElement.textContent = `Human detected in ${roomName}! AI is in control.`;
                        } else {
                            statusElement.textContent = `No human detected in ${roomName}. Awaiting...`;
                        }
                    }
                }
                
                // Rate-limit email alerts to once every 10 minutes (600,000 ms) per room
                // Use room-specific lastEmailTime tracking
                if (!monitor.lastEmailTime) {
                    monitor.lastEmailTime = null;
                }
                
                if (humanDetected && (monitor.lastEmailTime === null || (Date.now() - monitor.lastEmailTime) > 600000)) {
                    console.log(`Email time threshold passed for room ${roomId}. Sending alert...`);
                    
                    // --- MODIFICATION: Define a smaller size for the email alert image ---
                    const alertWidth = 640; // Smaller width
                    const alertHeight = 360; // Smaller height
                    const alertCanvas = document.createElement('canvas');
                    alertCanvas.width = alertWidth; // Use smaller width
                    alertCanvas.height = alertHeight; // Use smaller height
                    const alertCtx = alertCanvas.getContext('2d');
                    
                    // Draw the video frame, scaling it down to the smaller canvas size
                    alertCtx.drawImage(videoElement, 0, 0, alertWidth, alertHeight);
                    
                    // Draw bounding boxes around each detected person
                    alertCtx.strokeStyle = 'red';
                    alertCtx.lineWidth = 2; // Thinner line for smaller image
                    alertCtx.font = '14px Arial'; // Smaller font for smaller image
                    
                    humanDetections.forEach((detection, index) => {
                        // Scale the bounding box coordinates to match the new smaller image
                        const scaleX = alertWidth / videoElement.videoWidth;
                        const scaleY = alertHeight / videoElement.videoHeight;
                        const [x, y, width, height] = detection.bbox;
                        const scaledX = x * scaleX;
                        const scaledY = y * scaleY;
                        const scaledWidth = width * scaleX;
                        const scaledHeight = height * scaleY;
                        
                        // Draw the rectangle
                        alertCtx.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
                        
                        // Add confidence score label
                        const confidence = Math.round(detection.score * 100);
                        const label = `Person ${confidence}%`;
                        
                        // Draw label background
                        const textMetrics = alertCtx.measureText(label);
                        alertCtx.fillStyle = 'red';
                        alertCtx.fillRect(scaledX, Math.max(scaledY - 18, 0), textMetrics.width + 6, 18);
                        
                        // Draw label text
                        alertCtx.fillStyle = 'white';
                        alertCtx.fillText(label, scaledX + 3, Math.max(scaledY - 3, 15));
                        
                        console.log(`Detection ${index + 1} in room ${roomId}: bbox=[${scaledX}, ${scaledY}, ${scaledWidth}, ${scaledHeight}], confidence=${confidence}%`);
                    });
                    
                    try {
                        // --- MODIFICATION: Use JPEG format for much smaller file size ---
                        // A quality of 0.8 is a good balance.
                        const imageData = alertCanvas.toDataURL('image/jpeg', 0.8);
                        
                        // Validate image data before sending
                        if (imageData && imageData.length > 100) {
                            const currentRoom = allRoomsData.find(r => r.id === roomId);
                            const roomName = currentRoom ? currentRoom.name : 'Unknown Room';
                            
                            await fetch('/api/send-detection-email', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    image_data: imageData,
                                    room_name: roomName,
                                    room_id: roomId,
                                    is_global: false
                                })
                            });
                            
                            monitor.lastEmailTime = Date.now();
                            console.log(`Detection email sent successfully for room ${roomId}`);
                        } else {
                            console.error(`Invalid image data for email in room ${roomId}`);
                        }
                    } catch (emailError) {
                        console.error(`Failed to send detection email for room ${roomId}:`, emailError);
                    }
                }
                
            } catch (error) {
                console.error(`Error during detection for room ${roomId}:`, error);
                
                // Update status element only if user is viewing this room
                if (roomId === currentRoomId) {
                    const statusElement = document.getElementById('monitoring-status');
                    if (statusElement) {
                        statusElement.textContent = 'Error during detection.';
                    }
                }
            }
            
            // Reschedule the loop for THIS SPECIFIC ROOM
            if (monitor.isRunning) {
                monitor.intervalId = setTimeout(() => detectHumans(roomId), aiControlInterval);
            }
        }
    };

    const toggleGlobalWebcam = async () => {
        // Get UI elements - support both naming conventions
        const webcamContainer = document.getElementById('global-webcam-container') || webcamCardContainer;
        const videoElement = document.getElementById('global-webcam-video') || liveWebcamVideo;
        const button = document.getElementById('global-open-webcam-btn') || globalWebcamBtn;
        
        // Check if webcam is currently active - support both stream variables
        const currentStream = webcamStream || globalWebcamStream;
        
        if (currentStream) {
            // Stop webcam
            currentStream.getTracks().forEach(track => track.stop());
            
            // Clear both stream variables
            if (webcamStream) webcamStream = null;
            if (globalWebcamStream) globalWebcamStream = null;
            
            // Clear video source
            if (videoElement) {
                videoElement.srcObject = null;
            }
            
            // Hide webcam container
            if (webcamContainer) {
                webcamContainer.classList.add('hidden');
                // Remove global attribute if it exists
                webcamContainer.removeAttribute('data-global');
            }
            
            // Update button text
            if (button) {
                button.innerHTML = '<i class="fas fa-camera mr-2"></i>Open Webcam';
            }
            
            showNotification('Global webcam closed.', 'on');
            
        } else {
            // Start webcam
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                
                // Set both stream variables for compatibility
                webcamStream = stream;
                globalWebcamStream = stream;
                
                // Validate video element exists
                if (!videoElement) {
                    throw new Error('Webcam video element not found');
                }
                
                // Set video source
                videoElement.srcObject = stream;
                
                // Wait for metadata to load to ensure proper initialization
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Video metadata loading timeout'));
                    }, 5000);
                    
                    videoElement.onloadedmetadata = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    
                    // Fallback for already loaded metadata
                    if (videoElement.readyState >= 1) {
                        clearTimeout(timeout);
                        resolve();
                    }
                });
                
                // Show webcam container
                if (webcamContainer) {
                    webcamContainer.classList.remove('hidden');
                    webcamContainer.setAttribute('data-global', 'true');
                }
                
                // Update button text
                if (button) {
                    button.innerHTML = '<i class="fas fa-video-slash mr-2"></i>Close Webcam';
                }
                
                showNotification('Global webcam opened.', 'on');
                
            } catch (err) {
                console.error("Error accessing webcam:", err);
                
                // Provide specific error messages
                let errorMessage = 'Failed to access webcam. Please check permissions.';
                if (err.name === 'NotAllowedError') {
                    errorMessage = 'Camera permission denied.';
                } else if (err.name === 'NotFoundError') {
                    errorMessage = 'No camera device found.';
                } else if (err.name === 'NotReadableError') {
                    errorMessage = 'Camera is already in use by another application.';
                } else if (err.message.includes('not found')) {
                    errorMessage = 'Webcam video element not found in the page.';
                } else if (err.message.includes('timeout')) {
                    errorMessage = 'Camera initialization timeout. Please try again.';
                }
                
                showNotification(errorMessage, 'off');
                
                // Clean up on error - stop any active streams
                if (webcamStream) {
                    webcamStream.getTracks().forEach(track => track.stop());
                    webcamStream = null;
                }
                if (globalWebcamStream) {
                    globalWebcamStream.getTracks().forEach(track => track.stop());
                    globalWebcamStream = null;
                }
                
                // Reset UI state on error
                if (webcamContainer) {
                    webcamContainer.classList.add('hidden');
                    webcamContainer.removeAttribute('data-global');
                }
                if (button) {
                    button.innerHTML = '<i class="fas fa-camera mr-2"></i>Open Webcam';
                }
            }
        }
    };
    
    const toggleGlobalMonitoring = async () => {
        const button = document.getElementById('global-start-monitoring-btn');
        
        // --- LOGIC TO STOP GLOBAL MONITORING ---
        if (isGlobalMonitoringActive) {
            isGlobalMonitoringActive = false;
            isMonitoring = false; // The general flag
            if (monitoringIntervalId) clearTimeout(monitoringIntervalId);
            if (monitoringStream) monitoringStream.getTracks().forEach(track => track.stop());
            monitoringStream = null;
            
            button.innerHTML = '<i class="fas fa-eye mr-2"></i>Start Global Monitoring';
            button.classList.remove('monitoring-active-btn');
            document.getElementById('global-monitoring-card').classList.add('hidden');
            showNotification('Global AI monitoring stopped.', 'on');
            fetchRoomsAndAppliances(); // Re-render rooms to re-enable per-room buttons
            return;
        }
    
        // --- LOGIC TO START GLOBAL MONITORING ---
        try {
            // *** THE KEY FIX IS HERE: Shut down all active per-room monitors first ***
            if (activeMonitors.size > 0) {
                console.log(`Overriding ${activeMonitors.size} active room monitors...`);
                showNotification('Stopping all per-room monitors to start global session.', 'on');
                
                for (const [roomId, monitor] of activeMonitors.entries()) {
                    if (monitor.isRunning) {
                        monitor.isRunning = false;
                        if (monitor.intervalId) clearTimeout(monitor.intervalId);
                        if (monitor.stream) monitor.stream.getTracks().forEach(track => track.stop());
                        if (monitor.videoElement) monitor.videoElement.remove();
                        
                        // Silently update backend that AI control is off for this room
                        await fetch('/api/update-room-settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ room_id: roomId, ai_control: false })
                        });
                    }
                }
                activeMonitors.clear(); // Clear the map completely
            }
            
            // Now, proceed with starting the global monitor
            if (!model) await loadModel();
            if (!model) return;
    
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            monitoringStream = stream; // Use the single stream variable for the global session
            monitoringVideoElement.srcObject = stream;
            
            // *** THE CRITICAL FIX IS HERE ***
            // Wait for the video's metadata to load before proceeding. This solves the race condition.
            await new Promise(resolve => {
                monitoringVideoElement.onloadedmetadata = () => {
                    resolve();
                };
            });
            
            await monitoringVideoElement.play();
    
            // Now it's safe to update the state and UI
            isGlobalMonitoringActive = true;
            isMonitoring = true; // Set the general flag
            button.innerHTML = '<i class="fas fa-video-slash mr-2"></i>Stop Global Monitoring';
            button.classList.add('monitoring-active-btn');
            document.getElementById('global-monitoring-card').classList.remove('hidden');
            showNotification('Global AI monitoring started.', 'on');
            
            detectHumans(); // Start the detection loop (it will now know it's in global mode)
            fetchRoomsAndAppliances(); // Re-render rooms to disable per-room buttons
    
        } catch (err) {
            showNotification('Failed to start global monitoring. Check camera permissions.', 'off');
            console.error(err);
            // Ensure state is reset on failure
            isGlobalMonitoringActive = false;
            isMonitoring = false;
            button.innerHTML = '<i class="fas fa-eye mr-2"></i>Start Global Monitoring';
            button.classList.remove('monitoring-active-btn');
        }
    };
        
    
    const toggleMonitoring = async (roomId) => {
        const monitor = activeMonitors.get(roomId);
        const room = allRoomsData.find(r => r.id === roomId);
        if (!room) return;
    
        // --- LOGIC TO STOP A MONITORING SESSION ---
        if (monitor && monitor.isRunning) {
            monitor.isRunning = false;
            if (monitor.intervalId) clearTimeout(monitor.intervalId);
            if (monitor.stream) monitor.stream.getTracks().forEach(track => track.stop());
            if (monitor.videoElement) monitor.videoElement.remove(); // Clean up the DOM element
    
            activeMonitors.delete(roomId);
            console.log(`Monitoring stopped for room: ${room.name}`);
            showNotification(`AI monitoring stopped for ${room.name}.`, 'on');
            
            // Update backend and UI
            await fetch('/api/update-room-settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ room_id: roomId, ai_control: false })
            });
            renderAppliances(room.appliances, room.name);
            return;
        }
    
        // --- LOGIC TO START A NEW MONITORING SESSION ---
        try {
            if (!model) {
                await loadModel();
                if (!model) return;
            }
    
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            const videoElement = document.createElement('video');
            videoElement.srcObject = stream;
            videoElement.style.display = 'none'; // Keep it hidden
            document.body.appendChild(videoElement);
    
            await new Promise(resolve => videoElement.onloadedmetadata = resolve);
            await videoElement.play();
    
            const newMonitor = {
                roomId: roomId,
                stream: stream,
                videoElement: videoElement,
                intervalId: null, // Will be set by detectHumans
                isRunning: true
            };
    
            activeMonitors.set(roomId, newMonitor);
            console.log(`Monitoring started for room: ${room.name}`);
            showNotification(`AI monitoring started for ${room.name}.`, 'on');
    
            // Update backend and UI
            await fetch('/api/update-room-settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ room_id: roomId, ai_control: true })
            });
            renderAppliances(room.appliances, room.name);
            
            // Start the independent detection loop for this room
            detectHumans(roomId);
    
        } catch (err) {
            console.error(`Failed to start monitoring for room ${roomId}:`, err);
            showNotification(`Failed to start monitoring for ${room.name}. Check permissions.`, 'off');
        }
    };
    
    

    const openGlobalActionModal = (action) => {
        pendingGlobalAction = action;
        const selector = document.getElementById('global-room-selector');
        selector.innerHTML = ''; // Clear previous options

        if (allRoomsData.length === 0) {
            showNotification('Please add a room first.', 'off');
            return;
        }

        allRoomsData.forEach(room => {
            const option = document.createElement('option');
            option.value = room.id;
            option.textContent = room.name;
            selector.appendChild(option);
        });

        document.getElementById('select-room-modal').classList.remove('hidden');
    };

    const toggleWebcam = async () => {
        if (webcamStream) {
            // Stop webcam
            webcamStream.getTracks().forEach(track => track.stop());
            webcamStream = null;
            
            // Clear video source
            if (liveWebcamVideo) {
                liveWebcamVideo.srcObject = null;
            }
            
            // Update UI
            webcamCardContainer.classList.add('hidden');
            webcamBtn.innerHTML = '<i class="fas fa-camera mr-2"></i>Open Webcam';
            showNotification('Webcam turned off.', 'on');
            
            console.log('Webcam stream stopped successfully.');
        } else {
            // Start webcam
            try {
                // Check for media devices support (enhanced version feature)
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('MediaDevices API not supported');
                }
                
                // Request stream with enhanced quality settings when possible
                let videoConstraints = { video: true }; // Basic fallback
                
                try {
                    // Try enhanced quality first
                    videoConstraints = {
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    };
                    
                    const stream = await navigator.mediaDevices.getUserMedia(videoConstraints);
                    webcamStream = stream;
                } catch (qualityError) {
                    // Fallback to basic video if enhanced quality fails
                    console.warn('High quality video failed, falling back to basic video:', qualityError);
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    webcamStream = stream;
                }
                
                // Ensure video element exists (enhanced version feature)
                if (!liveWebcamVideo) {
                    console.error('Live webcam video element not found');
                    showNotification('Webcam video element not found.', 'off');
                    // Cleanup stream
                    webcamStream.getTracks().forEach(track => track.stop());
                    webcamStream = null;
                    return;
                }
                
                liveWebcamVideo.srcObject = webcamStream;
                
                // Enhanced loading with timeout (enhanced version feature)
                try {
                    await new Promise((resolve, reject) => {
                        const timeoutId = setTimeout(() => {
                            reject(new Error('Video load timeout'));
                        }, 5000); // 5 second timeout
                        
                        liveWebcamVideo.onloadedmetadata = () => {
                            clearTimeout(timeoutId);
                            resolve();
                        };
                        
                        liveWebcamVideo.onerror = (err) => {
                            clearTimeout(timeoutId);
                            reject(err);
                        };
                    });
                } catch (loadError) {
                    console.warn('Video metadata loading failed, proceeding anyway:', loadError);
                }
                
                // Update UI
                webcamCardContainer.classList.remove('hidden');
                webcamBtn.innerHTML = '<i class="fas fa-video-slash mr-2"></i>Close Webcam';
                showNotification('Webcam turned on.', 'on');
                
                console.log('Webcam stream started successfully.');
                
            } catch (err) {
                console.error("Error accessing webcam:", err);
                
                // Enhanced error messages (enhanced version feature)
                let errorMessage = 'Failed to access webcam.';
                if (err.name === 'NotAllowedError') {
                    errorMessage = 'Camera permission denied. Please allow camera access.';
                } else if (err.name === 'NotFoundError') {
                    errorMessage = 'No camera found on this device.';
                } else if (err.name === 'NotReadableError') {
                    errorMessage = 'Camera is already in use by another application.';
                } else if (err.name === 'OverconstrainedError') {
                    errorMessage = 'Camera does not support requested quality. Please try again.';
                } else if (err.message === 'MediaDevices API not supported') {
                    errorMessage = 'Your browser does not support camera access.';
                } else if (err.message === 'Video load timeout') {
                    errorMessage = 'Camera took too long to initialize.';
                } else {
                    // Fallback to basic message for unknown errors (basic version approach)
                    errorMessage = 'Failed to access webcam. Please check permissions.';
                }
                
                showNotification(errorMessage, 'off');
                
                // Cleanup any partial stream
                if (webcamStream) {
                    webcamStream.getTracks().forEach(track => track.stop());
                    webcamStream = null;
                }
            }
        }
    };
    
    const stopAllStreams = () => {
        if (webcamStream) {
            webcamStream.getTracks().forEach(track => track.stop());
            webcamStream = null;
        }
        if (isMonitoring) {
            isMonitoring = false;
            if (monitoringStream) {
                monitoringStream.getTracks().forEach(track => track.stop());
                monitoringStream = null;
            }
            if (monitoringIntervalId) {
                clearTimeout(monitoringIntervalId);
                monitoringIntervalId = null;
            }
        }
    };

    const saveNewRoomOrder = async (newOrder) => {
        try {
            await fetch('/api/save-room-order', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ order: newOrder })
            });
        } catch (error) {
            console.error("Failed to save new room order:", error);
        }
    };
    
    const saveNewApplianceOrder = async (roomId, newOrder) => {
        try {
            await fetch('/api/save-appliance-order', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ room_id: roomId, order: newOrder })
            });
        } catch (error) {
            console.error("Failed to save new appliance order:", error);
        }
    };

    const fetchRoomsAndAppliances = async () => {
        try {
            // Check if essential DOM elements exist before proceeding
            const roomContainer = document.getElementById('room-container');
            const roomsView = document.getElementById('rooms-view');
            const appliancesView = document.getElementById('appliances-view');
            
            if (!roomContainer || !roomsView || !appliancesView) {
                console.warn('Essential DOM elements not found, skipping fetch');
                return;
            }
            
            const response = await fetch('/api/get-rooms-and-appliances');
            if (!response.ok) {
                throw new Error('Failed to fetch rooms and appliances');
            }
            const rooms = await response.json();
            allRoomsData = rooms;
            renderRooms(rooms);
            
            if (currentRoomId) {
                const room = rooms.find(r => r.id === currentRoomId);
                if (room) {
                    renderAppliances(room.appliances, room.name);
                } else {
                    currentRoomId = null;
                    roomsView.classList.remove('hidden');
                    appliancesView.classList.add('hidden');
                }
            }
        } catch (error) {
            console.error('Error fetching data:', error);
            showNotification('Failed to load data.', 'off');
        }
    };

    const sendApplianceState = async (roomId, applianceId, state) => {
        try {
            const response = await fetch('/api/set-appliance-state', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ room_id: roomId, appliance_id: applianceId, state: state })
            });
            const result = await response.json();
            if (response.ok) {
                showNotification(result.message, state ? 'on' : 'off');
                fetchRoomsAndAppliances();
            } else {
                showNotification(`Error: ${result.message}`, 'off');
            }
        } catch (error) {
            console.error(error);
            showNotification('Failed to send command.', 'off');
        }
    };


    const renderRooms = (rooms) => {
        const container = document.getElementById('room-container');
        
        // Add null check to prevent the error
        if (!container) {
            console.error('room-container element not found in DOM');
            // Retry after a short delay if DOM isn't ready
            setTimeout(() => {
                const retryContainer = document.getElementById('room-container');
                if (retryContainer) {
                    renderRooms(rooms);
                } else {
                    console.error('room-container still not found after retry');
                }
            }, 100);
            return;
        }
        
        container.innerHTML = '';
        
        if (rooms.length > 0) {
            document.getElementById('rooms-view').classList.remove('hidden');
            document.getElementById('appliances-view').classList.add('hidden');
            
            // Global monitoring button state management
            if (isGlobalMonitoring) {
                const globalMonitoringBtn = document.getElementById('global-start-monitoring-btn');
                const globalMonitoringCard = document.getElementById('ai-monitoring-global-card');
                if (globalMonitoringBtn) {
                    globalMonitoringBtn.innerHTML = '<i class="fas fa-video-slash mr-2"></i>Stop Global Monitoring';
                }
                if (globalMonitoringCard) {
                    globalMonitoringCard.classList.remove('hidden');
                }
            } else {
                const globalMonitoringBtn = document.getElementById('global-start-monitoring-btn');
                const globalMonitoringCard = document.getElementById('ai-monitoring-global-card');
                if (globalMonitoringBtn) {
                    globalMonitoringBtn.innerHTML = '<i class="fas fa-eye mr-2"></i>Start Global Monitoring';
                }
                if (globalMonitoringCard) {
                    globalMonitoringCard.classList.add('hidden');
                }
            }
    
            rooms.forEach(room => {
                const roomCard = document.createElement('div');
                roomCard.setAttribute('data-slot', 'card');
                roomCard.setAttribute('data-id', room.id);
                roomCard.className = "bg-card text-card-foreground rounded-xl border p-6 shadow-sm transition-all relative";
                
                // MODIFICATION: Check live monitoring status from activeMonitors map
                const isCurrentlyMonitored = activeMonitors.has(room.id);
                const aiControlText = isCurrentlyMonitored ? 'AI Enabled' : 'AI Disabled';
                const aiStatusColor = isCurrentlyMonitored ? 'text-green-500' : 'text-gray-500';
                
                roomCard.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-xl font-bold cursor-pointer hover:underline" onclick="showAppliances('${room.id}')">${room.name}</h3>
                        <div class="flex space-x-2">
                            <button class="p-1 rounded-full hover:bg-muted transition-colors flex-shrink-0" title="Room Settings" onclick="event.stopPropagation(); openRoomSettings('${room.id}')">
                                <i class="h-4 w-4 fas fa-cog text-gray-400"></i>
                            </button>
                        </div>
                    </div>
                    <p class="text-gray-500">${room.appliances.length} Appliances</p>
                    <p class="text-sm mt-2"><span class="font-semibold ${aiStatusColor}">${aiControlText}</span></p>
                `;
                container.appendChild(roomCard);
            });
            
            // Initialize or reinitialize sortable functionality for drag-and-drop reordering
            if (roomSortable) {
                roomSortable.destroy();
            }
            roomSortable = new Sortable(container, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                onEnd: async (evt) => {
                    if (evt.oldIndex !== evt.newIndex) {
                        const newOrder = Array.from(container.children).map(child => child.dataset.id);
                        await saveNewRoomOrder(newOrder);
                    }
                }
            });
        } else {
            container.innerHTML = `<p class="text-center text-gray-500">No rooms added yet. Click "Add Room" to get started!</p>`;
        }
    };

    
    const updateTimerDisplay = (card, appliance) => {
        const timerElement = card.querySelector('.timer-display');
        const cancelButton = card.querySelector('.cancel-timer-btn');
        const toggleInput = card.querySelector('input[type="checkbox"]');
        if (!timerElement || !cancelButton || !toggleInput) return;

        clearInterval(timerIntervals[appliance.id]);

        if (appliance.timer && appliance.state) {
            const update = () => {
                const timeLeft = Math.floor(appliance.timer - Date.now() / 1000);
                if (timeLeft > 0) {
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    timerElement.textContent = `Timer: ${minutes}m ${seconds}s`;
                    timerElement.classList.remove('hidden');
                    cancelButton.classList.remove('hidden');
                } else {
                    timerElement.textContent = `Timer Off`;
                    clearInterval(timerIntervals[appliance.id]);
                    cancelButton.classList.add('hidden');
                    sendApplianceState(currentRoomId, appliance.id, false);
                    toggleInput.checked = false;
                }
            };
            update();
            timerIntervals[appliance.id] = setInterval(update, 1000);
        } else {
            timerElement.classList.add('hidden');
            cancelButton.classList.add('hidden');
        }
    };

    const renderAppliances = (appliances, roomName) => {
        const container = document.getElementById('appliance-container');
        container.innerHTML = '';
        
        // Update appliances heading with room name
        const appliancesHeading = document.getElementById('appliances-heading');
        if (appliancesHeading) {
            appliancesHeading.textContent = `${roomName} Appliances`;
        }
            
        // Switch views from rooms to appliances
        document.getElementById('rooms-view').classList.add('hidden');
        document.getElementById('appliances-view').classList.remove('hidden');
    
        // UPDATED MONITORING BUTTON LOGIC
        const monitoringBtn = document.getElementById('start-monitoring-btn');
        if (monitoringBtn) {
            if (activeMonitors.has(currentRoomId)) {
                monitoringBtn.innerHTML = '<i class="fas fa-video-slash mr-2"></i>Stop Monitoring';
                monitoringBtn.classList.replace('bg-primary-accent', 'bg-red-500');
            } else {
                monitoringBtn.innerHTML = '<i class="fas fa-eye mr-2"></i>Start Monitoring';
                monitoringBtn.classList.replace('bg-red-500', 'bg-primary-accent');
            }
            // Disable the button if global monitoring is active
            monitoringBtn.disabled = isGlobalMonitoringActive;
            monitoringBtn.title = isGlobalMonitoringActive ? "Stop global monitoring to enable this." : "";
        }
    
        if (appliances.length > 0) {
            appliances.forEach(appliance => {
                const is_on = appliance.state;
                const is_locked = appliance.locked;
                const applianceCard = document.createElement('div');
                
                // Set card attributes
                applianceCard.setAttribute('data-slot', 'card');
                applianceCard.setAttribute('data-id', appliance.id);
                applianceCard.className = "bg-card text-card-foreground rounded-xl border py-6 px-6 shadow-sm transition-all flex flex-col items-stretch relative";
    
                // Build appliance card HTML with all controls
                applianceCard.innerHTML = `
                    <div class="flex items-center justify-between mb-4">
                        <div data-slot="card-title" class="leading-none font-semibold pr-2 flex items-center">
                            <span class="appliance-name">${appliance.name}</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <button class="p-1 rounded-full hover:bg-muted transition-colors flex-shrink-0" 
                                    title="Set Manual Override" 
                                    onclick="toggleLock('${currentRoomId}', '${appliance.id}')">
                                <i id="lock-icon-${appliance.id}" 
                                   class="h-4 w-4 fas ${is_locked ? 'fa-lock text-red-500' : 'fa-unlock text-gray-400'}"></i>
                            </button>
                            <button class="p-1 rounded-full hover:bg-muted transition-colors flex-shrink-0" 
                                    title="Set Timer" 
                                    onclick="openTimerModal('${currentRoomId}', '${appliance.id}')">
                                <i class="h-4 w-4 fas fa-clock text-gray-400"></i>
                            </button>
                            <button class="p-1 rounded-full hover:bg-muted transition-colors flex-shrink-0" 
                                    title="Appliance Settings" 
                                    onclick="openApplianceSettings('${currentRoomId}', '${appliance.id}')">
                                <i class="h-4 w-4 fas fa-cog text-gray-400"></i>
                            </button>
                            <button class="p-1 rounded-full hover:bg-muted transition-colors flex-shrink-0 cancel-timer-btn hidden" 
                                    title="Cancel Timer" 
                                    onclick="openConfirmationModal('cancel-timer', '${currentRoomId}', '${appliance.id}')">
                                <i class="h-4 w-4 fas fa-times-circle text-red-400"></i>
                            </button>
                        </div>
                    </div>
                    <div data-slot="card-content" class="flex-grow flex items-center justify-between">
                        <i class="fas fa-lightbulb text-2xl ${is_on ? 'text-primary-accent' : 'text-gray-400 dark:text-gray-600'} transition-colors"></i>
                        <label class="custom-toggle-switch">
                            <input type="checkbox" 
                                   data-room-id="${currentRoomId}" 
                                   data-appliance-id="${appliance.id}" 
                                   ${is_on ? 'checked' : ''}>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <span class="timer-display absolute bottom-2 left-2 text-xs font-semibold text-primary-accent hidden"></span>
                `;
                
                container.appendChild(applianceCard);
    
                // Add toggle event listener for appliance state changes
                const toggleInput = applianceCard.querySelector('input[type="checkbox"]');
                toggleInput.onchange = () => {
                    const newState = toggleInput.checked;
                    sendApplianceState(currentRoomId, appliance.id, newState);
                };
                
                // Update timer display for this appliance
                updateTimerDisplay(applianceCard, appliance);
            });
    
            // Initialize or reinitialize sortable functionality for drag-and-drop reordering
            if (applianceSortable) {
                applianceSortable.destroy();
            }
            
            applianceSortable = new Sortable(container, {
                animation: 150,
                ghostClass: 'sortable-ghost',
                onEnd: async (evt) => {
                    // Save new order only if position actually changed
                    if (evt.oldIndex !== evt.newIndex) {
                        const newOrder = Array.from(container.children).map(child => child.dataset.id);
                        await saveNewApplianceOrder(currentRoomId, newOrder);
                    }
                }
            });
            
        } else {
            // Display message when no appliances are present
            container.innerHTML = `
                <p class="text-center text-gray-500">
                    No appliances in this room yet. Click "Add Appliance" to get started!
                </p>
            `;
        }
    
        // Additional UI updates for global monitoring state awareness
        updateMonitoringUIState();
    };
        
    // Helper function to update monitoring-related UI states
    const updateMonitoringUIState = () => {
        // Update other monitoring-related UI elements if they exist
        const monitoringIndicators = document.querySelectorAll('.monitoring-indicator');
        monitoringIndicators.forEach(indicator => {
            if (isGlobalMonitoring) {
                indicator.classList.add('global-active');
                indicator.setAttribute('title', 'Global monitoring is active');
            } else {
                indicator.classList.remove('global-active');
                indicator.removeAttribute('title');
            }
        });
    
        // Update room-specific controls based on global monitoring state
        const roomControls = document.querySelectorAll('.room-specific-control');
        roomControls.forEach(control => {
            if (isGlobalMonitoring) {
                control.classList.add('disabled-by-global');
                control.setAttribute('disabled', 'true');
            } else {
                control.classList.remove('disabled-by-global');
                control.removeAttribute('disabled');
            }
        });
    };

    const openRoomSettings = (roomId) => {
        const room = allRoomsData.find(r => r.id === roomId);
        if (!room) return;
        document.getElementById('edit-room-id').value = roomId;
        document.getElementById('edit-room-name').value = room.name;
        const aiControlSwitch = document.getElementById('ai-control-switch');
        aiControlSwitch.dataset.state = room.ai_control ? 'checked' : 'off';
        if (room.ai_control) {
            aiControlSwitch.classList.add('data-[state=checked]');
        } else {
            aiControlSwitch.classList.remove('data-[state=checked]');
        }
        document.getElementById('settings-room-modal').classList.remove('hidden');
    };

    document.getElementById('cancel-room-settings-btn').addEventListener('click', () => {
        document.getElementById('settings-room-modal').classList.add('hidden');
    });

    document.getElementById('delete-room-btn').addEventListener('click', () => {
        const roomId = document.getElementById('edit-room-id').value;
        openConfirmationModal('delete-room', roomId);
    });

    document.getElementById('settings-room-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        
        // Find the submit button to provide user feedback
        const submitButton = e.currentTarget.querySelector('button[type="submit"]');
        const originalButtonText = submitButton.innerHTML;
    
        // --- UX UPDATE: Disable button and show saving state ---
        submitButton.disabled = true;
        submitButton.innerHTML = `<i class="fas fa-spinner fa-spin mr-2"></i>Saving...`;
    
        // Get form values
        const roomId = document.getElementById('edit-room-id').value;
        const newName = document.getElementById('edit-room-name').value;
        const aiControl = document.getElementById('ai-control-switch').dataset.state === 'checked';
        
        try {
            const response = await fetch('/api/update-room-settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    room_id: roomId, 
                    name: newName, 
                    ai_control: aiControl 
                })
            });
    
            // The response.ok check is the correct way to see if the request was successful (e.g., status 200)
            if (response.ok) {
                showNotification('Room settings updated!', 'on');
                document.getElementById('settings-room-modal').classList.add('hidden');
                fetchRoomsAndAppliances(); // Refresh the main view with new data
            } else {
                // Handle errors reported by the server (e.g., status 400, 500)
                const result = await response.json();
                showNotification(`Error: ${result.message}`, 'off');
            }
    
        } catch (error) {
            // Handle network errors (e.g., server is down, no internet connection)
            console.error('Form submission failed:', error);
            showNotification('Failed to save room settings. Check your connection.', 'off');
        } finally {
            // --- UX UPDATE: Re-enable button and restore original text ---
            // This 'finally' block ensures the button is always re-enabled, even if an error occurs.
            submitButton.disabled = false;
            submitButton.innerHTML = originalButtonText;
        }
    });
    // Universal Confirmation Modal Logic
    let currentAction = null;
    let currentData = null;

    const openConfirmationModal = (action, ...data) => {
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationTitle = document.getElementById('confirmation-title');
        const confirmationMessage = document.getElementById('confirmation-message');
        const confirmActionBtn = document.getElementById('confirm-action-btn');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
    
        currentAction = action;
        currentData = data;
        
        // Set title and message based on action
        switch(action) {
            case 'delete-room':
                confirmationTitle.textContent = 'Delete Room';
                confirmationMessage.textContent = 'Are you sure you want to delete this room? This action cannot be undone and will also delete all appliances in this room.';
                confirmActionBtn.textContent = 'Delete Room';
                confirmActionBtn.className = 'px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors';
                break;
            case 'delete-appliance':
                confirmationTitle.textContent = 'Delete Appliance';
                confirmationMessage.textContent = 'Are you sure you want to delete this appliance? This action cannot be undone.';
                confirmActionBtn.textContent = 'Delete Appliance';
                confirmActionBtn.className = 'px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors';
                break;
            case 'cancel-timer':
                confirmationTitle.textContent = 'Cancel Timer';
                confirmationMessage.textContent = 'Are you sure you want to cancel the timer for this appliance?';
                confirmActionBtn.textContent = 'Cancel Timer';
                confirmActionBtn.className = 'px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 transition-colors';
                break;
            default:
                confirmationTitle.textContent = 'Confirm Action';
                confirmationMessage.textContent = 'Are you sure you want to proceed?';
                confirmActionBtn.textContent = 'Confirm';
                confirmActionBtn.className = 'px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors';
        }
        
        confirmationModal.classList.remove('hidden');
    
        confirmActionBtn.onclick = async () => {
            confirmationModal.classList.add('hidden');
            if (currentAction === 'delete-room') {
                const [roomId] = currentData;
                try {
                    const response = await fetch('/api/delete-room', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ room_id: roomId })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showNotification('Room deleted successfully!', 'on');
                        fetchRoomsAndAppliances();
                    } else {
                        showNotification(`Error: ${result.message}`, 'off');
                    }
                } catch (error) {
                    console.error(error);
                    showNotification('Failed to delete room.', 'off');
                }
            } else if (currentAction === 'delete-appliance') {
                const [roomId, applianceId] = currentData;
                try {
                    const response = await fetch('/api/delete-appliance', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ room_id: roomId, appliance_id: applianceId })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showNotification('Appliance deleted successfully!', 'on');
                        document.getElementById('settings-appliance-modal').classList.add('hidden');
                        fetchRoomsAndAppliances();
                    } else {
                        showNotification(`Error: ${result.message}`, 'off');
                    }
                } catch (error) {
                    console.error(error);
                    showNotification('Failed to delete appliance.', 'off');
                }
            } else if (currentAction === 'cancel-timer') {
                const [roomId, applianceId] = currentData;
                try {
                    const response = await fetch('/api/set-timer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ room_id: roomId, appliance_id: applianceId, timer: null })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showNotification('Timer cancelled.', 'on');
                        fetchRoomsAndAppliances();
                    } else {
                        showNotification(`Error: ${result.message}`, 'off');
                    }
                } catch (error) {
                    console.error(error);
                    showNotification('Failed to cancel timer.', 'off');
                }
            }
            currentAction = null;
            currentData = null;
        };
    
        confirmCancelBtn.addEventListener('click', () => {
            confirmationModal.classList.add('hidden');
            currentAction = null;
            currentData = null;
        });
    };

    const saveApplianceName = async (inputElement) => {
        const roomId = currentRoomId;
        const applianceId = inputElement.dataset.applianceId;
        const newName = inputElement.value;

        if (newName === "") {
            inputElement.value = "Unnamed Appliance";
            showNotification("Appliance name cannot be empty.", "off");
            return;
        }

        try {
            const response = await fetch('/api/set-appliance-name', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ room_id: roomId, appliance_id: applianceId, name: newName })
            });
            const result = await response.json();
            if (response.ok) {
                showNotification(`Appliance name updated to "${newName}".`, 'on');
            } else {
                showNotification(`Error: ${result.message}`, 'off');
            }
        } catch (error) {
            console.error(error);
            showNotification('Failed to update appliance name.', 'off');
        } finally {
            inputElement.disabled = true;
        }
    };

    const openApplianceSettings = (roomId, applianceId) => {
        const room = allRoomsData.find(r => r.id === roomId);
        if (!room) return;
        const appliance = room.appliances.find(a => a.id === applianceId);
        
        document.getElementById('settings-edit-room-id').value = roomId;
        document.getElementById('edit-appliance-id').value = applianceId;
        document.getElementById('edit-appliance-name').value = appliance.name;
        document.getElementById('edit-appliance-relay').value = appliance.relay_number;
        
        const roomSelector = document.getElementById('edit-room-selector');
        roomSelector.innerHTML = '';
        allRoomsData.forEach(r => {
            const option = document.createElement('option');
            option.value = r.id;
            option.textContent = r.name;
            if (r.id === roomId) {
                option.selected = true;
            }
            roomSelector.appendChild(option);
        });
        
        const advancedSettingsToggle = document.querySelector('.advanced-settings-toggle');
        const advancedSettings = document.getElementById('advanced-settings');
        advancedSettingsToggle.onclick = () => {
            advancedSettings.classList.toggle('hidden');
        };

        document.getElementById('settings-appliance-modal').classList.remove('hidden');
    };

    document.getElementById('delete-appliance-btn').addEventListener('click', () => {
        const roomId = document.getElementById('settings-edit-room-id').value;
        const applianceId = document.getElementById('edit-appliance-id').value;
        openConfirmationModal('delete-appliance', roomId, applianceId);
    });

    document.getElementById('cancel-appliance-settings-btn').addEventListener('click', () => {
        document.getElementById('settings-appliance-modal').classList.add('hidden');
    });

    document.getElementById('settings-appliance-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const roomId = document.getElementById('settings-edit-room-id').value;
        const applianceId = document.getElementById('edit-appliance-id').value;
        const newName = document.getElementById('edit-appliance-name').value;
        const newRelay = document.getElementById('edit-appliance-relay').value;
        const newRoomId = document.getElementById('edit-room-selector').value;
        
        try {
            const response = await fetch('/api/update-appliance-settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    room_id: roomId, 
                    appliance_id: applianceId, 
                    name: newName, 
                    relay_number: newRelay, 
                    new_room_id: newRoomId 
                })
            });
            const result = await response.json();
            if (response.ok) {
                showNotification('Appliance settings updated!', 'on');
                document.getElementById('settings-appliance-modal').classList.add('hidden');
                fetchRoomsAndAppliances();
            } else {
                showNotification(`Error: ${result.message}`, 'off');
            }
        } catch (error) {
            console.error(error);
            showNotification('Failed to save settings.', 'off');
        }
    });

    const openTimerModal = async (roomId, applianceId) => {
        document.getElementById('timer-room-id').value = roomId;
        document.getElementById('timer-appliance-id').value = applianceId;
        document.getElementById('timer-modal').classList.remove('hidden');
    };

    document.getElementById('cancel-timer-btn').addEventListener('click', () => {
        document.getElementById('timer-modal').classList.add('hidden');
    });

    document.getElementById('timer-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const roomId = document.getElementById('timer-room-id').value;
        const applianceId = document.getElementById('timer-appliance-id').value;
        
        let timerTimestamp = null;
        const hours = parseInt(document.getElementById('timer-duration-hours').value) || 0;
        const minutes = parseInt(document.getElementById('timer-duration-minutes').value) || 0;
        const datetimeInput = document.getElementById('timer-datetime').value;

        if (hours > 0 || minutes > 0) {
            const timerDurationMinutes = hours * 60 + minutes;
            if (timerDurationMinutes > 0) {
                 timerTimestamp = Math.floor(Date.now() / 1000) + timerDurationMinutes * 60;
            }
        } else if (datetimeInput) {
            const futureDate = new Date(datetimeInput);
            if (futureDate.getTime() > Date.now()) {
                timerTimestamp = Math.floor(futureDate.getTime() / 1000);
            }
        }

        if (timerTimestamp) {
            try {
                const response = await fetch('/api/set-timer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ room_id: roomId, appliance_id: applianceId, timer: timerTimestamp })
                });
                const result = await response.json();
                if (response.ok) {
                    showNotification('Timer set successfully!', 'on');
                    document.getElementById('timer-modal').classList.add('hidden');
                    fetchRoomsAndAppliances();
                } else {
                    showNotification(`Error: ${result.message}`, 'off');
                }
            } catch (error) {
                console.error(error);
                showNotification('Failed to set timer.', 'off');
            }
        } else {
            showNotification('Please set a valid future time or duration.', 'off');
        }
    });

    const toggleLock = async (roomId, applianceId) => {
        try {
            const response = await fetch('/api/get-rooms-and-appliances');
            const rooms = await response.json();
            const appliance = rooms.find(r => r.id === roomId).appliances.find(a => a.id === applianceId);
            const newState = !appliance.locked;

            const lockResponse = await fetch('/api/set-lock', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ room_id: roomId, appliance_id: applianceId, locked: newState })
            });
            const result = await lockResponse.json();
            if (lockResponse.ok) {
                showNotification(`Appliance is now ${newState ? 'locked' : 'unlocked'}.`, 'on');
                fetchRoomsAndAppliances();
            } else {
                showNotification(`Error: ${result.message}`, 'off');
            }
        } catch (error) {
            console.error(error);
            showNotification('Failed to update lock state.', 'off');
        }
    };

    document.getElementById('back-to-rooms-btn').addEventListener('click', () => {
        currentRoomId = null;
        document.getElementById('rooms-view').classList.remove('hidden');
        document.getElementById('appliances-view').classList.add('hidden');
    });

    // Close webcam when navigating away
    window.addEventListener('beforeunload', () => {
        if (webcamStream) {
            webcamStream.getTracks().forEach(track => track.stop());
        }
    });

    document.getElementById('open-webcam-btn').addEventListener('click', toggleWebcam);
    document.getElementById('close-webcam-btn').addEventListener('click', toggleWebcam);


    const showAppliances = (roomId) => {
        const room = allRoomsData.find(r => r.id === roomId);
        if (room) {
            currentRoomId = roomId;
            renderAppliances(room.appliances, room.name);
        }
    };

    const initModalsAndListeners = () => {
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
        const confirmActionBtn = document.getElementById('confirm-action-btn');


        document.getElementById('global-open-webcam-btn').addEventListener('click', toggleGlobalWebcam);
        document.getElementById('global-start-monitoring-btn').addEventListener('click', toggleGlobalMonitoring);
        
        document.getElementById('add-room-btn').addEventListener('click', () => {
            document.getElementById('add-room-modal').classList.remove('hidden');
        });
        document.getElementById('cancel-room-btn').addEventListener('click', () => {
            document.getElementById('add-room-modal').classList.add('hidden');
        });
        document.getElementById('add-room-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const roomName = document.getElementById('new-room-name').value;
            const response = await fetch('/api/add-room', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: roomName })
            });
            const result = await response.json();
            if (response.ok) {
                document.getElementById('add-room-modal').classList.add('hidden');
                fetchRoomsAndAppliances();
                showNotification('Room added successfully!', 'on');
            } else {
                showNotification(`Error: ${result.message}`, 'off');
            }
        });

        document.getElementById('add-appliance-btn').addEventListener('click', () => {
            document.getElementById('add-appliance-modal').classList.remove('hidden');
        });
        document.getElementById('cancel-appliance-btn').addEventListener('click', () => {
            document.getElementById('add-appliance-modal').classList.add('hidden');
        });
        document.getElementById('add-appliance-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const applianceName = document.getElementById('new-appliance-name').value;
            const relayNumber = document.getElementById('new-appliance-relay').value;
            const response = await fetch('/api/add-appliance', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ room_id: currentRoomId, name: applianceName, relay_number: relayNumber })
            });
            const result = await response.json();
            if (response.ok) {
                document.getElementById('add-appliance-modal').classList.add('hidden');
                fetchRoomsAndAppliances();
                showNotification('Appliance added successfully!', 'on');
            } else {
                showNotification(`Error: ${result.message}`, 'off');
            }
        });

        document.getElementById('cancel-appliance-settings-btn').addEventListener('click', () => {
            document.getElementById('settings-appliance-modal').classList.add('hidden');
        });
        document.getElementById('settings-appliance-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const roomId = document.getElementById('edit-room-id').value;
            const applianceId = document.getElementById('edit-appliance-id').value;
            const newName = document.getElementById('edit-appliance-name').value;
            const newRelay = document.getElementById('edit-appliance-relay').value;
            const newRoomId = document.getElementById('edit-room-selector').value;
            
            try {
                const response = await fetch('/api/update-appliance-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ room_id: roomId, appliance_id: applianceId, name: newName, relay_number: newRelay, new_room_id: newRoomId })
                });
                const result = await response.json();
                if (response.ok) {
                    showNotification('Appliance settings updated!', 'on');
                    document.getElementById('settings-appliance-modal').classList.add('hidden');
                    fetchRoomsAndAppliances();
                } else {
                    showNotification(`Error: ${result.message}`, 'off');
                }
            } catch (error) {
                console.error(error);
                showNotification('Failed to save settings.', 'off');
            }
        });

        document.getElementById('cancel-timer-btn').addEventListener('click', () => {
            document.getElementById('timer-modal').classList.add('hidden');
        });
        
        document.getElementById('timer-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const roomId = document.getElementById('timer-room-id').value;
            const applianceId = document.getElementById('timer-appliance-id').value;
            
            let timerTimestamp = null;
            const hours = parseInt(document.getElementById('timer-duration-hours').value) || 0;
            const minutes = parseInt(document.getElementById('timer-duration-minutes').value) || 0;
            const datetimeInput = document.getElementById('timer-datetime').value;

            if (hours > 0 || minutes > 0) {
                const timerDurationMinutes = hours * 60 + minutes;
                if (timerDurationMinutes > 0) {
                     timerTimestamp = Math.floor(Date.now() / 1000) + timerDurationMinutes * 60;
                }
            } else if (datetimeInput) {
                const futureDate = new Date(datetimeInput);
                if (futureDate.getTime() > Date.now()) {
                    timerTimestamp = Math.floor(futureDate.getTime() / 1000);
                }
            }

            if (timerTimestamp) {
                try {
                    const response = await fetch('/api/set-timer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ room_id: roomId, appliance_id: applianceId, timer: timerTimestamp })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showNotification('Timer set successfully!', 'on');
                        document.getElementById('timer-modal').classList.add('hidden');
                        fetchRoomsAndAppliances();
                    } else {
                        showNotification(`Error: ${result.message}`, 'off');
                    }
                } catch (error) {
                    console.error(error);
                    showNotification('Failed to set timer.', 'off');
                }
            } else {
                showNotification('Please set a valid future time or duration.', 'off');
            }
        });

        confirmActionBtn.addEventListener('click', async () => {
            confirmationModal.classList.add('hidden');
            if (currentAction === 'delete-room') {
                const [roomId] = currentData;
                try {
                    const response = await fetch('/api/delete-room', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ room_id: roomId })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showNotification('Room deleted successfully!', 'on');
                        fetchRoomsAndAppliances();
                    } else {
                        showNotification(`Error: ${result.message}`, 'off');
                    }
                } catch (error) {
                    console.error(error);
                    showNotification('Failed to delete room.', 'off');
                }
            } else if (currentAction === 'delete-appliance') {
                const [roomId, applianceId] = currentData;
                try {
                    const response = await fetch('/api/delete-appliance', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ room_id: roomId, appliance_id: applianceId })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showNotification('Appliance deleted successfully!', 'on');
                        document.getElementById('settings-appliance-modal').classList.add('hidden');
                        fetchRoomsAndAppliances();
                    } else {
                        showNotification(`Error: ${result.message}`, 'off');
                    }
                } catch (error) {
                    console.error(error);
                    showNotification('Failed to delete appliance.', 'off');
                }
            } else if (currentAction === 'cancel-timer') {
                const [roomId, applianceId] = currentData;
                try {
                    const response = await fetch('/api/set-timer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ room_id: roomId, appliance_id: applianceId, timer: null })
                    });
                    const result = await response.json();
                    if (response.ok) {
                        showNotification('Timer cancelled.', 'on');
                        fetchRoomsAndAppliances();
                    } else {
                        showNotification(`Error: ${result.message}`, 'off');
                    }
                } catch (error) {
                    console.error(error);
                    showNotification('Failed to cancel timer.', 'off');
                }
            }
        });
        confirmCancelBtn.addEventListener('click', () => {
            confirmationModal.classList.add('hidden');
        });

        document.getElementById('ai-control-switch').addEventListener('click', async (e) => {
            const switchBtn = e.currentTarget;
            const isChecked = switchBtn.dataset.state === 'checked';
            const roomId = document.getElementById('edit-room-id').value;

            try {
                const response = await fetch('/api/update-room-settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ room_id: roomId, ai_control: !isChecked })
                });
                const result = await response.json();
                if (response.ok) {
                    if (isChecked) {
                        switchBtn.dataset.state = 'off';
                        switchBtn.classList.remove('data-[state=checked]');
                    } else {
                        switchBtn.dataset.state = 'checked';
                        switchBtn.classList.add('data-[state=checked]');
                    }
                    showNotification(`AI Control is now ${!isChecked ? 'ON' : 'OFF'}.`, 'on');
                    fetchRoomsAndAppliances();
                } else {
                    showNotification(`Error: ${result.message}`, 'off');
                }
            } catch (error) {
                console.error(error);
                showNotification('Failed to update AI control.', 'off');
            }
        });
    };

    window.addEventListener('DOMContentLoaded', () => {
        fetchRoomsAndAppliances();
        setInterval(fetchRoomsAndAppliances, 3000);
        initModalsAndListeners();
        loadModel();
    });
</script>
{% endblock %}
